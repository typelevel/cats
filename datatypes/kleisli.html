<!DOCTYPE html><html><head><title>Cats: Kleisli</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Cats contributors" /><meta name="description" content="Lightweight, modular, and extensible library for functional programming" /><meta name="og:image" content="/cats/img/poster.png" /><meta name="image" property="og:image" content="/cats/img/poster.png" /><meta name="og:title" content="Cats: Kleisli" /><meta name="title" property="og:title" content="Cats: Kleisli" /><meta name="og:site_name" content="Cats" /><meta name="og:url" content="http://typelevel.org/cats/" /><meta name="og:type" content="website" /><meta name="og:description" content="Lightweight, modular, and extensible library for functional programming" /><link rel="icon" type="image/png" href="/cats/img/favicon.png" /><meta name="twitter:title" content="Cats: Kleisli" /><meta name="twitter:image" content="/cats/img/poster.png" /><meta name="twitter:description" content="Lightweight, modular, and extensible library for functional programming" /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/cats/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/cats/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/cats/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/cats/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/cats/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/cats/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/cats/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/cats/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/cats/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/cats/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/cats/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/cats/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/cats/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/cats/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/cats/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/cats/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/cats/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/cats/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/cats/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/cats/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/cats/highlight/styles/atom-one-light.css" /><link rel="stylesheet" href="/cats/css/pattern-style.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/cats/" class="brand"><div class="brand-wrapper"><span>Cats</span></div></a></li><li><a href="/cats/datatypes/chain.html" class="">Chain</a></li><li><a href="/cats/datatypes/const.html" class="">Const</a></li><li><a href="/cats/datatypes/contt.html" class="">ContT</a></li><li><a href="/cats/datatypes.html" class="">Data Types</a></li><li><a href="/cats/datatypes/either.html" class="">Either</a></li><li><a href="/cats/datatypes/eithert.html" class="">EitherT</a></li><li><a href="/cats/datatypes/eval.html" class="">Eval</a></li><li><a href="/cats/datatypes/freeapplicative.html" class="">FreeApplicatives</a></li><li><a href="/cats/datatypes/freemonad.html" class="">FreeMonads</a></li><li><a href="/cats/datatypes/functionk.html" class="">FunctionK</a></li><li><a href="/cats/datatypes/id.html" class="">Id</a></li><li><a href="/cats/datatypes/ior.html" class="">Ior</a></li><li><a href="/cats/datatypes/iort.html" class="">IorT</a></li><li><a href="/cats/datatypes/kleisli.html" class=" active ">Kleisli</a></li><li><a href="/cats/datatypes/nel.html" class="">NonEmptyList</a></li><li><a href="/cats/datatypes/nested.html" class="">Nested</a></li><li><a href="/cats/datatypes/oneand.html" class="">OneAnd</a></li><li><a href="/cats/datatypes/optiont.html" class="">OptionT</a></li><li><a href="/cats/datatypes/state.html" class="">State</a></li><li><a href="/cats/datatypes/validated.html" class="">Validated</a></li><li><a href="/cats/datatypes/writer.html" class="">Writer</a></li><li><a href="/cats/datatypes/writert.html" class="">WriterT</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/typelevel/cats" target="_blank" rel="noopener noreferrer"><i class="fa fa-eye"></i><span>Watchers<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/typelevel/cats" target="_blank" rel="noopener noreferrer"><i class="fa fa-star-o"></i><span>Stars<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('Cats Lightweight, modular, and extensible library for functional programming');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('Cats Lightweight, modular, and extensible library for functional programming');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="typelevel" data-github-repo="cats"><div class="content-wrapper"><section><h1 id="kleisli">Kleisli</h1>
<p>Kleisli enables composition of functions that return a monadic value, for instance an <code class="language-plaintext highlighter-rouge">Option[Int]</code> 
or a <code class="language-plaintext highlighter-rouge">Either[String, List[Double]]</code>, without having functions take an <code class="language-plaintext highlighter-rouge">Option</code> or <code class="language-plaintext highlighter-rouge">Either</code> as a parameter, 
which can be strange and unwieldy.</p>

<p>We may also have several functions which depend on some environment and want a nice way to compose these functions
to ensure they all receive the same environment. Or perhaps we have functions which depend on their own “local”
configuration and all the configurations together make up a “global” application configuration. How do we
have these functions play nice with each other despite each only knowing about their own local requirements?</p>

<p>These situations are where <code class="language-plaintext highlighter-rouge">Kleisli</code> is immensely helpful.</p>

<h2 id="functions">Functions</h2>
<p>One of the most useful properties of functions is that they <strong>compose</strong>. That is, given a function
<code class="language-plaintext highlighter-rouge">A =&gt; B</code> and a function <code class="language-plaintext highlighter-rouge">B =&gt; C</code>, we can combine them to create a new function <code class="language-plaintext highlighter-rouge">A =&gt; C</code>. It is through
this compositional property that we are able to write many small functions and compose them together
to create a larger one that suits our needs.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">twice</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span>
  <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>

<span class="k">val</span> <span class="nv">countCats</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">String</span> <span class="k">=</span>
  <span class="n">x</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="s">"1 cat"</span> <span class="k">else</span> <span class="n">s</span><span class="s">"$x cats"</span>

<span class="k">val</span> <span class="nv">twiceAsManyCats</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">String</span> <span class="k">=</span>
  <span class="n">twice</span> <span class="n">andThen</span> <span class="n">countCats</span> <span class="c1">// equivalent to: countCats compose twice  </span>
</code></pre></div></div>

<p>Thus.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">twiceAsManyCats</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// "2 cats"</span>
<span class="c1">// res0: String = "2 cats"</span>
</code></pre></div></div>

<p>Sometimes, our functions will need to return monadic values. For instance, consider the following set of functions.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">parse</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">s</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">s</span><span class="o">.</span><span class="py">matches</span><span class="o">(</span><span class="s">"-?[0-9]+"</span><span class="o">))</span> <span class="nc">Some</span><span class="o">(</span><span class="nv">s</span><span class="o">.</span><span class="py">toInt</span><span class="o">)</span> <span class="k">else</span> <span class="nc">None</span>

<span class="k">val</span> <span class="nv">reciprocal</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">Some</span><span class="o">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">i</span><span class="o">)</span> <span class="k">else</span> <span class="nc">None</span>
</code></pre></div></div>

<p>As it stands we cannot use <code class="language-plaintext highlighter-rouge">Function1.compose</code> (or <code class="language-plaintext highlighter-rouge">Function1.andThen</code>) to compose these two functions.
The output type of <code class="language-plaintext highlighter-rouge">parse</code> is <code class="language-plaintext highlighter-rouge">Option[Int]</code> whereas the input type of <code class="language-plaintext highlighter-rouge">reciprocal</code> is <code class="language-plaintext highlighter-rouge">Int</code>.</p>

<p>This is where <code class="language-plaintext highlighter-rouge">Kleisli</code> comes into play.</p>

<h2 id="kleisli-1">Kleisli</h2>
<p>At its core, <code class="language-plaintext highlighter-rouge">Kleisli[F[_], A, B]</code> is just a wrapper around the function <code class="language-plaintext highlighter-rouge">A =&gt; F[B]</code>. Depending on the
properties of the <code class="language-plaintext highlighter-rouge">F[_]</code>, we can do different things with <code class="language-plaintext highlighter-rouge">Kleisli</code>s. For instance, if <code class="language-plaintext highlighter-rouge">F[_]</code> has a
<code class="language-plaintext highlighter-rouge">FlatMap[F]</code> instance (we can call <code class="language-plaintext highlighter-rouge">flatMap</code> on <code class="language-plaintext highlighter-rouge">F[A]</code> values), we can
compose two <code class="language-plaintext highlighter-rouge">Kleisli</code>s much like we can two functions.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.FlatMap</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Kleisli</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">compose</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">k</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Z</span>, <span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">FlatMap</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Z</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Z</span>, <span class="kt">B</span><span class="o">](</span><span class="n">z</span> <span class="k">=&gt;</span> <span class="nv">k</span><span class="o">.</span><span class="py">run</span><span class="o">(</span><span class="n">z</span><span class="o">).</span><span class="py">flatMap</span><span class="o">(</span><span class="n">run</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Returning to our earlier example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Bring in cats.FlatMap[Option] instance</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">val</span> <span class="nv">parse</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">Option</span>,<span class="kt">String</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Kleisli</span><span class="o">((</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">s</span><span class="o">.</span><span class="py">matches</span><span class="o">(</span><span class="s">"-?[0-9]+"</span><span class="o">))</span> <span class="nc">Some</span><span class="o">(</span><span class="nv">s</span><span class="o">.</span><span class="py">toInt</span><span class="o">)</span> <span class="k">else</span> <span class="nc">None</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">reciprocal</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">Option</span>,<span class="kt">Int</span>,<span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Kleisli</span><span class="o">((</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">Some</span><span class="o">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">i</span><span class="o">)</span> <span class="k">else</span> <span class="nc">None</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">parseAndReciprocal</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">Option</span>,<span class="kt">String</span>,<span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">reciprocal</span><span class="o">.</span><span class="py">compose</span><span class="o">(</span><span class="n">parse</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Kleisli#andThen</code> can be defined similarly.</p>

<p>It is important to note that the <code class="language-plaintext highlighter-rouge">F[_]</code> having a <code class="language-plaintext highlighter-rouge">FlatMap</code> (or a <code class="language-plaintext highlighter-rouge">Monad</code>) instance is not a hard requirement -
we can do useful things with weaker requirements. Such an example would be <code class="language-plaintext highlighter-rouge">Kleisli#map</code>, which only requires
that <code class="language-plaintext highlighter-rouge">F[_]</code> have a <code class="language-plaintext highlighter-rouge">Functor</code> instance (e.g. is equipped with <code class="language-plaintext highlighter-rouge">map: F[A] =&gt; (A =&gt; B) =&gt; F[B]</code>).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Functor</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Kleisli</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">C</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">C</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span>, <span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span>, <span class="kt">C</span><span class="o">](</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="nv">F</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nf">run</span><span class="o">(</span><span class="n">a</span><span class="o">))(</span><span class="n">f</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Below are some more methods on <code class="language-plaintext highlighter-rouge">Kleisli</code> that can be used as long as the constraint on <code class="language-plaintext highlighter-rouge">F[_]</code>
is satisfied.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Method    | Constraint on `F[_]`
--------- | -------------------
andThen   | FlatMap
compose   | FlatMap
flatMap   | FlatMap
lower     | Monad
map       | Functor
traverse  | Applicative
</code></pre></div></div>

<h3 id="type-class-instances">Type class instances</h3>
<p>The type class instances for <code class="language-plaintext highlighter-rouge">Kleisli</code>, like that for functions, often fix the input type (and the <code class="language-plaintext highlighter-rouge">F[_]</code>) and leave
the output type free. What type class instances it has tends to depend on what instances the <code class="language-plaintext highlighter-rouge">F[_]</code> has. For
instance, <code class="language-plaintext highlighter-rouge">Kleisli[F, A, B]</code> has a <code class="language-plaintext highlighter-rouge">Functor</code> instance as long as the chosen <code class="language-plaintext highlighter-rouge">F[_]</code> does. It has a <code class="language-plaintext highlighter-rouge">Monad</code>
instance as long as the chosen <code class="language-plaintext highlighter-rouge">F[_]</code> does. The instances in Cats are laid out in a way such that implicit
resolution will pick up the most specific instance it can (depending on the <code class="language-plaintext highlighter-rouge">F[_]</code>).</p>

<p>An example of a <code class="language-plaintext highlighter-rouge">Monad</code> instance for <code class="language-plaintext highlighter-rouge">Kleisli</code> is shown below.</p>

<p><em>Note</em>: the example below assumes usage of the <a href="https://github.com/typelevel/kind-projector">kind-projector compiler plugin</a> and will not compile if it is not being used in a project.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="c1">// We can define a FlatMap instance for Kleisli if the F[_] we chose has a FlatMap instance</span>
<span class="c1">// Note the input type and F are fixed, with the output type left free</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="nf">kleisliFlatMap</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">Z</span><span class="o">](</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">FlatMap</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">FlatMap</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Z</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">FlatMap</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Z</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Z</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Z</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Z</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">Kleisli</span><span class="o">(</span><span class="n">z</span> <span class="k">=&gt;</span> <span class="nv">fa</span><span class="o">.</span><span class="py">run</span><span class="o">(</span><span class="n">z</span><span class="o">).</span><span class="py">flatMap</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="py">run</span><span class="o">(</span><span class="n">z</span><span class="o">)))</span>

    <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Z</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Z</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">Kleisli</span><span class="o">(</span><span class="n">z</span> <span class="k">=&gt;</span> <span class="nv">fa</span><span class="o">.</span><span class="py">run</span><span class="o">(</span><span class="n">z</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>

    <span class="k">def</span> <span class="nf">tailRecM</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Z</span>, <span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]])</span> <span class="k">=</span>
      <span class="nc">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Z</span>, <span class="kt">B</span><span class="o">]({</span> <span class="n">z</span> <span class="k">=&gt;</span> <span class="nc">FlatMap</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">tailRecM</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">{</span> <span class="nf">f</span><span class="o">(</span><span class="k">_</span><span class="o">).</span><span class="py">run</span><span class="o">(</span><span class="n">z</span><span class="o">)</span> <span class="o">}</span> <span class="o">})</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Below is a table of some of the type class instances <code class="language-plaintext highlighter-rouge">Kleisli</code> can have depending on what instances <code class="language-plaintext highlighter-rouge">F[_]</code> has.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Type class     | Constraint on `F[_]`
-------------- | -------------------
Functor        | Functor
Apply          | Apply
Applicative    | Applicative
FlatMap        | FlatMap
Monad          | Monad
Arrow          | Monad
Split          | FlatMap
Strong         | Functor
SemigroupK*    | FlatMap
MonoidK*       | Monad
</code></pre></div></div>

<p>*These instances only exist for Kleisli arrows with identical input and output types; that is, 
<code class="language-plaintext highlighter-rouge">Kleisli[F, A, A]</code> for some type A. These instances use Kleisli composition as the <code class="language-plaintext highlighter-rouge">combine</code> operation,
and <code class="language-plaintext highlighter-rouge">Monad.pure</code> as the <code class="language-plaintext highlighter-rouge">empty</code> value.</p>

<p>Also, there is an instance of <code class="language-plaintext highlighter-rouge">Monoid[Kleisli[F, A, B]]</code> if there is an instance of <code class="language-plaintext highlighter-rouge">Monoid[F[B]]</code>. 
<code class="language-plaintext highlighter-rouge">Monoid.combine</code> here creates a new Kleisli arrow which takes an <code class="language-plaintext highlighter-rouge">A</code> value and feeds it into each 
of the combined Kleisli arrows, which together return two <code class="language-plaintext highlighter-rouge">F[B]</code> values. Then, they are combined into one 
using the <code class="language-plaintext highlighter-rouge">Monoid[F[B]]</code> instance.</p>

<h2 id="other-uses">Other uses</h2>
<h3 id="monad-transformers">Monad Transformers</h3>
<p>Many data types have a monad transformer equivalent that allows us to compose the <code class="language-plaintext highlighter-rouge">Monad</code> instance of the data
type with any other <code class="language-plaintext highlighter-rouge">Monad</code> instance. For instance, <code class="language-plaintext highlighter-rouge">OptionT[F[_], A]</code> allows us to compose the monadic properties
of <code class="language-plaintext highlighter-rouge">Option</code> with any other <code class="language-plaintext highlighter-rouge">F[_]</code>, such as a <code class="language-plaintext highlighter-rouge">List</code>. This allows us to work with nested contexts/effects in a
nice way (for example, in for-comprehensions).</p>

<p><code class="language-plaintext highlighter-rouge">Kleisli</code> can be viewed as the monad transformer for functions. Recall that at its essence, <code class="language-plaintext highlighter-rouge">Kleisli[F, A, B]</code>
is just a function <code class="language-plaintext highlighter-rouge">A =&gt; F[B]</code>, with niceties to make working with the value we actually care about, the <code class="language-plaintext highlighter-rouge">B</code>, easy.
<code class="language-plaintext highlighter-rouge">Kleisli</code> allows us to take the effects of functions and have them play nice with the effects of any other <code class="language-plaintext highlighter-rouge">F[_]</code>.</p>

<p>This may raise the question, what exactly is the “effect” of a function?</p>

<p>Well, if we take a look at any function, we can see it takes some input and produces some output with it, without
having touched the input (assuming the function is pure, i.e.
<a href="https://en.wikipedia.org/wiki/Referential_transparency_%28computer_science%29">referentially transparent</a>).
That is, we take a read-only value, and produce some value with it. For this reason, the type class instances for
functions often refer to the function as a <code class="language-plaintext highlighter-rouge">Reader</code>. For instance, it is common to hear about the <code class="language-plaintext highlighter-rouge">Reader</code> monad.
In the same spirit, Cats defines a <code class="language-plaintext highlighter-rouge">Reader</code> type alias along the lines of:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We want A =&gt; B, but Kleisli provides A =&gt; F[B]. To make the types/shapes match,</span>
<span class="c1">// we need an F[_] such that providing it a type A is equivalent to A</span>
<span class="c1">// This can be thought of as the type-level equivalent of the identity function</span>
<span class="k">type</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">A</span>

<span class="k">type</span> <span class="kt">Reader</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Kleisli</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
<span class="k">object</span> <span class="nc">Reader</span> <span class="o">{</span>
  <span class="c1">// Lifts a plain function A =&gt; B into a Kleisli, giving us access</span>
  <span class="c1">// to all the useful methods and type class instances</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Reader</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Kleisli</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">type</span> <span class="kt">ReaderT</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
<span class="k">val</span> <span class="nv">ReaderT</span> <span class="k">=</span> <span class="nc">Kleisli</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">ReaderT</code> value alias exists to allow users to use the <code class="language-plaintext highlighter-rouge">Kleisli</code> companion object as if it were <code class="language-plaintext highlighter-rouge">ReaderT</code>, if
they were so inclined.</p>

<p>The topic of functions as a read-only environment brings us to our next common use case of <code class="language-plaintext highlighter-rouge">Kleisli</code> - configuration.</p>

<h3 id="configuration">Configuration</h3>
<p>Functional programming advocates the creation of programs and modules by composing smaller, simpler modules. This
philosophy intentionally mirrors that of function composition - write many small functions, and compose them
to build larger ones. After all, our programs are just functions.</p>

<p>Let’s look at some example modules, where each module has its own configuration that is validated by a function.
If the configuration is good, we return a <code class="language-plaintext highlighter-rouge">Some</code> of the module, otherwise a <code class="language-plaintext highlighter-rouge">None</code>. This example uses <code class="language-plaintext highlighter-rouge">Option</code> for
simplicity - if you want to provide error messages or other failure context, consider using <code class="language-plaintext highlighter-rouge">Either</code> instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">DbConfig</span><span class="o">(</span><span class="n">url</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">user</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">pass</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">trait</span> <span class="nc">Db</span>
<span class="k">object</span> <span class="nc">Db</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">fromDbConfig</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">Option</span>, <span class="kt">DbConfig</span>, <span class="kt">Db</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">ServiceConfig</span><span class="o">(</span><span class="n">addr</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">port</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="k">trait</span> <span class="nc">Service</span>
<span class="k">object</span> <span class="nc">Service</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">fromServiceConfig</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">Option</span>, <span class="kt">ServiceConfig</span>, <span class="kt">Service</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We have two independent modules, a <code class="language-plaintext highlighter-rouge">Db</code> (allowing access to a database) and a <code class="language-plaintext highlighter-rouge">Service</code> (supporting an API to provide
data over the web). Both depend on their own configuration parameters. Neither know or care about the other, as it
should be. However our application needs both of these modules to work. It is plausible we then have a more global
application configuration.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">AppConfig</span><span class="o">(</span><span class="n">dbConfig</span><span class="k">:</span> <span class="kt">DbConfig</span><span class="o">,</span> <span class="n">serviceConfig</span><span class="k">:</span> <span class="kt">ServiceConfig</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">App</span><span class="o">(</span><span class="n">db</span><span class="k">:</span> <span class="kt">Db</span><span class="o">,</span> <span class="n">service</span><span class="k">:</span> <span class="kt">Service</span><span class="o">)</span>
</code></pre></div></div>

<p>As it stands, we cannot use both <code class="language-plaintext highlighter-rouge">Kleisli</code> validation functions together nicely - one takes a <code class="language-plaintext highlighter-rouge">DbConfig</code>, the
other a <code class="language-plaintext highlighter-rouge">ServiceConfig</code>. That means the <code class="language-plaintext highlighter-rouge">FlatMap</code> (and by extension, the <code class="language-plaintext highlighter-rouge">Monad</code>) instances differ (recall the
input type is fixed in the type class instances). However, there is a nice function on <code class="language-plaintext highlighter-rouge">Kleisli</code> called <code class="language-plaintext highlighter-rouge">local</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Kleisli</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">local</span><span class="o">[</span><span class="kt">AA</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">AA</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">AA</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Kleisli</span><span class="o">(</span><span class="nv">f</span><span class="o">.</span><span class="py">andThen</span><span class="o">(</span><span class="n">run</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>What <code class="language-plaintext highlighter-rouge">local</code> allows us to do is essentially “expand” our input type to a more “general” one. In our case, we
can take a <code class="language-plaintext highlighter-rouge">Kleisli</code> that expects a <code class="language-plaintext highlighter-rouge">DbConfig</code> or <code class="language-plaintext highlighter-rouge">ServiceConfig</code> and turn it into one that expects an <code class="language-plaintext highlighter-rouge">AppConfig</code>,
as long as we tell it how to go from an <code class="language-plaintext highlighter-rouge">AppConfig</code> to the other configs.</p>

<p>Now we can create our application config validator!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Kleisli</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">Z</span>, <span class="kt">A</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Z</span>, <span class="kt">B</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">FlatMap</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Z</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Kleisli</span><span class="o">(</span><span class="n">z</span> <span class="k">=&gt;</span> <span class="nv">F</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="nf">run</span><span class="o">(</span><span class="n">z</span><span class="o">))(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="py">run</span><span class="o">(</span><span class="n">z</span><span class="o">)))</span>

  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Z</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Kleisli</span><span class="o">(</span><span class="n">z</span> <span class="k">=&gt;</span> <span class="nv">F</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nf">run</span><span class="o">(</span><span class="n">z</span><span class="o">))(</span><span class="n">f</span><span class="o">))</span>

  <span class="k">def</span> <span class="nf">local</span><span class="o">[</span><span class="kt">ZZ</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">ZZ</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">ZZ</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Kleisli</span><span class="o">(</span><span class="nv">f</span><span class="o">.</span><span class="py">andThen</span><span class="o">(</span><span class="n">run</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">DbConfig</span><span class="o">(</span><span class="n">url</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">user</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">pass</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">trait</span> <span class="nc">Db</span>
<span class="k">object</span> <span class="nc">Db</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">fromDbConfig</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">Option</span>, <span class="kt">DbConfig</span>, <span class="kt">Db</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">ServiceConfig</span><span class="o">(</span><span class="n">addr</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">port</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="k">trait</span> <span class="nc">Service</span>
<span class="k">object</span> <span class="nc">Service</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">fromServiceConfig</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">Option</span>, <span class="kt">ServiceConfig</span>, <span class="kt">Service</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">AppConfig</span><span class="o">(</span><span class="n">dbConfig</span><span class="k">:</span> <span class="kt">DbConfig</span><span class="o">,</span> <span class="n">serviceConfig</span><span class="k">:</span> <span class="kt">ServiceConfig</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">App</span><span class="o">(</span><span class="n">db</span><span class="k">:</span> <span class="kt">Db</span><span class="o">,</span> <span class="n">service</span><span class="k">:</span> <span class="kt">Service</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">appFromAppConfig</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">Option</span>, <span class="kt">AppConfig</span>, <span class="kt">App</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">db</span> <span class="k">&lt;-</span> <span class="nv">Db</span><span class="o">.</span><span class="py">fromDbConfig</span><span class="o">.</span><span class="py">local</span><span class="o">[</span><span class="kt">AppConfig</span><span class="o">](</span><span class="nv">_</span><span class="o">.</span><span class="py">dbConfig</span><span class="o">)</span>
    <span class="n">sv</span> <span class="k">&lt;-</span> <span class="nv">Service</span><span class="o">.</span><span class="py">fromServiceConfig</span><span class="o">.</span><span class="py">local</span><span class="o">[</span><span class="kt">AppConfig</span><span class="o">](</span><span class="nv">_</span><span class="o">.</span><span class="py">serviceConfig</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="k">new</span> <span class="nc">App</span><span class="o">(</span><span class="n">db</span><span class="o">,</span> <span class="n">sv</span><span class="o">)</span>
</code></pre></div></div>

<p>What if we need a module that doesn’t need any config validation, say a strategy to log events? We would have such a
module be instantiated from a config directly, without an <code class="language-plaintext highlighter-rouge">Option</code> - we would have something like
<code class="language-plaintext highlighter-rouge">Kleisli[Id, LogConfig, Log]</code> (alternatively, <code class="language-plaintext highlighter-rouge">Reader[LogConfig, Log]</code>). However, this won’t play nice with our other
<code class="language-plaintext highlighter-rouge">Kleisli</code>s since those use <code class="language-plaintext highlighter-rouge">Option</code> instead of <code class="language-plaintext highlighter-rouge">Id</code>.</p>

<p>We can define a <code class="language-plaintext highlighter-rouge">lift</code> method on <code class="language-plaintext highlighter-rouge">Kleisli</code> (available already on <code class="language-plaintext highlighter-rouge">Kleisli</code> in Cats) that takes a type parameter <code class="language-plaintext highlighter-rouge">G[_]</code>
such that <code class="language-plaintext highlighter-rouge">G</code> has an <code class="language-plaintext highlighter-rouge">Applicative</code> instance and lifts a <code class="language-plaintext highlighter-rouge">Kleisli</code> value such that its output type is <code class="language-plaintext highlighter-rouge">G[F[B]]</code>. This
allows us to then lift a <code class="language-plaintext highlighter-rouge">Reader[A, B]</code> into a <code class="language-plaintext highlighter-rouge">Kleisli[G, A, B]</code>. Note that lifting a <code class="language-plaintext highlighter-rouge">Reader[A, B]</code> into some <code class="language-plaintext highlighter-rouge">G[_]</code>
is equivalent to having a <code class="language-plaintext highlighter-rouge">Kleisli[G, A, B]</code> since <code class="language-plaintext highlighter-rouge">Reader[A, B]</code> is just a type alias for <code class="language-plaintext highlighter-rouge">Kleisli[Id, A, B]</code>, and
<code class="language-plaintext highlighter-rouge">type Id[A] = A</code> so <code class="language-plaintext highlighter-rouge">G[Id[A]]</code> is equivalent to <code class="language-plaintext highlighter-rouge">G[A]</code>.</p>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/cats/highlight/highlight.pack.js"></script><script>
// For all code blocks, copy the language from the containing div
// to the inner code tag (where hljs expects it to be)
const langPrefix = 'language-';
document.querySelectorAll(`div[class^='${langPrefix}']`).forEach(function(div) {
  div.classList.forEach(function(cssClass) {
    if (cssClass.startsWith(langPrefix)) {
      const lang = cssClass.substring(langPrefix.length);
      div.querySelectorAll('pre code').forEach(function(code) {
        code.classList.add(lang);
      });
    }
  });
});

hljs.configure({languages:['scala','java','bash']});
hljs.initHighlightingOnLoad();
      </script><script>console.info('\x57\x65\x62\x73\x69\x74\x65\x20\x62\x75\x69\x6c\x74\x20\x77\x69\x74\x68\x3a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x5f\x5f\x0a\x20\x20\x20\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x5f\x20\x20\x2f\x20\x2f\x5f\x20\x20\x20\x20\x20\x20\x5f\x5f\x5f\x5f\x20\x5f\x5f\x5f\x20\x20\x28\x5f\x29\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x28\x5f\x29\x20\x2f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x0a\x20\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x60\x5f\x5f\x20\x5c\x2f\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x20\x2f\x20\x5f\x5f\x2f\x20\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x0a\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x5f\x2f\x20\x2f\x20\x2f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x5f\x5f\x2f\x20\x2f\x20\x20\x2f\x20\x2f\x5f\x2f\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x20\x2f\x5f\x2f\x20\x20\x5f\x5f\x28\x5f\x5f\x20\x20\x29\x0a\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2e\x5f\x5f\x5f\x2f\x5c\x5f\x5f\x2f\x20\x20\x20\x20\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x2f\x20\x20\x20\x5c\x5f\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x0a\x0a\x68\x74\x74\x70\x73\x3a\x2f\x2f\x34\x37\x64\x65\x67\x2e\x67\x69\x74\x68\x75\x62\x2e\x69\x6f\x2f\x73\x62\x74\x2d\x6d\x69\x63\x72\x6f\x73\x69\x74\x65\x73')</script><script>((window.gitter = {}).chat = {}).options = {
room: 'typelevel/cats'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/cats/js/main.js"></script></body></html>