<html><head><title>Cats</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Cats contributors" /><meta name="description" content="Lightweight, modular, and extensible library for functional programming" /><meta name="og:image" content="/cats/img/poster.png" /><meta name="og:title" content="Cats" /><meta name="og:site_name" content="Cats" /><meta name="og:url" content="http://typelevel.org/cats/" /><meta name="og:type" content="website" /><meta name="og:description" content="Lightweight, modular, and extensible library for functional programming" /><link rel="icon" type="image/png" href="/cats/img/favicon.png" /><meta name="twitter:title" content="Cats" /><meta name="twitter:image" content="http://typelevel.org/cats/img/poster.png" /><meta name="twitter:description" content="Lightweight, modular, and extensible library for functional programming" /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/cats/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/cats/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/cats/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/cats/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/cats/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/cats/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/cats/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/cats/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/cats/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/cats/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/cats/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/cats/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/cats/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/cats/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/cats/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/cats/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/cats/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/cats/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/cats/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/cats/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/cats/highlight/styles/atom-one-light.css" /><link rel="stylesheet" href="/cats/css/style.css" /><link rel="stylesheet" href="/cats/css/palette.css" /><link rel="stylesheet" href="/cats/css/codemirror.css" /><link rel="stylesheet" href="/cats/css/kazari-style.css" /><link rel="stylesheet" href="/cats/css/monokai.css" /><link rel="stylesheet" href="/cats/css/override.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/cats/" class="brand"><div class="brand-wrapper"><span>Cats</span></div></a></li>               <li><a href="/cats/datatypes.html" class="">Data Types</a></li> <li><a href="/cats/datatypes/const.html" class="">Const</a></li> <li><a href="/cats/datatypes/either.html" class="">Either</a></li> <li><a href="/cats/datatypes/eval.html" class="">Eval</a></li> <li><a href="/cats/datatypes/freeapplicative.html" class="">FreeApplicatives</a></li> <li><a href="/cats/datatypes/freemonad.html" class=" active ">FreeMonads</a></li> <li><a href="/cats/datatypes/functionk.html" class="">FunctionK</a></li> <li><a href="/cats/datatypes/id.html" class="">Id</a></li> <li><a href="/cats/datatypes/ior.html" class="">Ior</a></li> <li><a href="/cats/datatypes/kleisli.html" class="">Kleisli</a></li> <li><a href="/cats/datatypes/nel.html" class="">NonEmptyList</a></li> <li><a href="/cats/datatypes/oneand.html" class="">OneAnd</a></li> <li><a href="/cats/datatypes/optiont.html" class="">OptionT</a></li> <li><a href="/cats/datatypes/eithert.html" class="">EitherT</a></li> <li><a href="/cats/datatypes/iort.html" class="">IorT</a></li> <li><a href="/cats/datatypes/state.html" class="">State</a></li> <li><a href="/cats/datatypes/validated.html" class="">Validated</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/typelevel/cats"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/typelevel/cats"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('Cats Lightweight, modular, and extensible library for functional programming');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('Cats Lightweight, modular, and extensible library for functional programming');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="typelevel" data-github-repo="cats"><div class="content-wrapper"><section><h1 id="free-monad">Free Monad</h1>

<h2 id="what-is-it">What is it?</h2>

<p>A <em>free monad</em> is a construction which allows you to build a <em>monad</em>
from any <em>Functor</em>. Like other <em>monads</em>, it is a pure way to represent
and manipulate computations.</p>

<p>In particular, <em>free monads</em> provide a practical way to:</p>

<ul>
  <li>represent stateful computations as data, and run them</li>
  <li>run recursive computations in a stack-safe way</li>
  <li>build an embedded DSL (domain-specific language)</li>
  <li>retarget a computation to another interpreter using natural transformations</li>
</ul>

<blockquote>
  <p>(In cats, the type representing a <em>free monad</em> is abbreviated as <code class="highlighter-rouge">Free[_]</code>.)</p>
</blockquote>

<h2 id="using-free-monads">Using Free Monads</h2>

<p>If you’d like to use cats’ free monad, you’ll need to add a library dependency
for the <code class="highlighter-rouge">cats-free</code> module.</p>

<p>A good way to get a sense for how <em>free monads</em> work is to see them in
action. The next section uses <code class="highlighter-rouge">Free[_]</code> to create an embedded DSL
(Domain Specific Language).</p>

<p>If you’re interested in the theory behind <em>free monads</em>, the
<a href="#what-is-free-in-theory">What is Free in theory?</a> section discusses free monads
in terms of category theory.</p>

<h3 id="study-your-topic">Study your topic</h3>

<p>Let’s imagine that we want to create a DSL for a key-value store. We
want to be able to do three things with keys:</p>

<ul>
  <li><em>put</em> a <code class="highlighter-rouge">value</code> into the store, associated with its <code class="highlighter-rouge">key</code>.</li>
  <li><em>get</em> a <code class="highlighter-rouge">value</code> from the store given its <code class="highlighter-rouge">key</code>.</li>
  <li><em>delete</em> a <code class="highlighter-rouge">value</code> from the store given its <code class="highlighter-rouge">key</code>.</li>
</ul>

<p>The idea is to write a sequence of these operations in the embedded
DSL as a “program”, compile the “program”, and finally execute the
“program” to interact with the actual key-value store.</p>

<p>For example:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">put</span><span class="o">(</span><span class="s">"toto"</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">get</span><span class="o">(</span><span class="s">"toto"</span><span class="o">)</span> <span class="c1">// returns 3
</span><span class="n">delete</span><span class="o">(</span><span class="s">"toto"</span><span class="o">)</span>
</code></pre>
</div>

<p>But we want:</p>

<ul>
  <li>the computation to be represented as a pure, immutable value</li>
  <li>to separate the creation and execution of the program</li>
  <li>to be able to support many different methods of execution</li>
</ul>

<h3 id="study-your-grammar">Study your grammar</h3>

<p>We have 3 commands to interact with our KeyValue store:</p>

<ul>
  <li><code class="highlighter-rouge">Put</code> a value associated with a key into the store</li>
  <li><code class="highlighter-rouge">Get</code> a value associated with a key out of the store</li>
  <li><code class="highlighter-rouge">Delete</code> a value associated with a key from the store</li>
</ul>

<h3 id="create-an-adt-representing-your-grammar">Create an ADT representing your grammar</h3>

<p>ADT stands for <em>Algebraic Data Type</em>. In this context, it refers to a
closed set of types which can be combined to build up complex,
recursive values.</p>

<p>We need to create an ADT to represent our key-value operations:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">KVStoreA</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">Put</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">KVStoreA</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Get</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">KVStoreA</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Delete</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">KVStoreA</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
</code></pre>
</div>

<h3 id="free-your-adt">Free your ADT</h3>

<p>There are five basic steps to “freeing” the ADT:</p>

<ol>
  <li>Create a type based on <code class="highlighter-rouge">Free[_]</code> and <code class="highlighter-rouge">KVStoreA[_]</code>.</li>
  <li>Create smart constructors for <code class="highlighter-rouge">KVStore[_]</code> using <code class="highlighter-rouge">liftF</code>.</li>
  <li>Build a program out of key-value DSL operations.</li>
  <li>Build a compiler for programs of DSL operations.</li>
  <li>Execute our compiled program.</li>
</ol>

<h4 id="create-a-free-type-based-on-your-adt">1. Create a <code class="highlighter-rouge">Free</code> type based on your ADT</h4>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.free.Free</span>

<span class="k">type</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">KVStoreA</span>, <span class="kt">A</span><span class="o">]</span>
</code></pre>
</div>

<h4 id="create-smart-constructors-using-liftf">2. Create smart constructors using <code class="highlighter-rouge">liftF</code></h4>

<p>These methods will make working with our DSL a lot nicer, and will
lift <code class="highlighter-rouge">KVStoreA[_]</code> values into our <code class="highlighter-rouge">KVStore[_]</code> monad (note the
missing “A” in the second type).</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.free.Free.liftF</span>

<span class="c1">// Put returns nothing (i.e. Unit).
</span><span class="k">def</span> <span class="n">put</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">liftF</span><span class="o">[</span><span class="kt">KVStoreA</span>, <span class="kt">Unit</span><span class="o">](</span><span class="nc">Put</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">))</span>

<span class="c1">// Get returns a T value.
</span><span class="k">def</span> <span class="n">get</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">liftF</span><span class="o">[</span><span class="kt">KVStoreA</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]](</span><span class="nc">Get</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">key</span><span class="o">))</span>

<span class="c1">// Delete returns nothing (i.e. Unit).
</span><span class="k">def</span> <span class="n">delete</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">liftF</span><span class="o">(</span><span class="nc">Delete</span><span class="o">(</span><span class="n">key</span><span class="o">))</span>

<span class="c1">// Update composes get and set, and returns nothing.
</span><span class="k">def</span> <span class="n">update</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">vMaybe</span> <span class="k">&lt;-</span> <span class="n">get</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">key</span><span class="o">)</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">vMaybe</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">v</span> <span class="k">=&gt;</span> <span class="n">put</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">key</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">v</span><span class="o">))).</span><span class="n">getOrElse</span><span class="o">(</span><span class="nc">Free</span><span class="o">.</span><span class="n">pure</span><span class="o">(()))</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre>
</div>

<h4 id="build-a-program">3. Build a program</h4>

<p>Now that we can construct <code class="highlighter-rouge">KVStore[_]</code> values we can use our DSL to
write “programs” using a <em>for-comprehension</em>:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">program</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">put</span><span class="o">(</span><span class="s">"wild-cats"</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">update</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"wild-cats"</span><span class="o">,</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">12</span><span class="o">))</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">put</span><span class="o">(</span><span class="s">"tame-cats"</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
    <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">get</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"wild-cats"</span><span class="o">)</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">delete</span><span class="o">(</span><span class="s">"tame-cats"</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">n</span>
</code></pre>
</div>

<p>This looks like a monadic flow. However, it just builds a recursive
data structure representing the sequence of operations.</p>

<h4 id="write-a-compiler-for-your-program">4. Write a compiler for your program</h4>

<p>As you may have understood now, <code class="highlighter-rouge">Free[_]</code> is used to create an embedded
DSL. By itself, this DSL only represents a sequence of operations
(defined by a recursive data structure); it doesn’t produce anything.</p>

<p><code class="highlighter-rouge">Free[_]</code> is a programming language inside your programming language!</p>

<p><strong>So, like any other programming language, we need to compile our
  abstract language into an <em>effective</em> language and then run it.</strong></p>

<p>To do this, we will use a <em>natural transformation</em> between type
containers.  Natural transformations go between types like <code class="highlighter-rouge">F[_]</code> and
<code class="highlighter-rouge">G[_]</code> (this particular transformation would be written as
<code class="highlighter-rouge">FunctionK[F,G]</code> or as done here using the symbolic
alternative as <code class="highlighter-rouge">F ~&gt; G</code>).</p>

<p>In our case, we will use a simple mutable map to represent our key
value store:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.arrow.FunctionK</span>
<span class="k">import</span> <span class="nn">cats.</span><span class="o">{</span><span class="nc">Id</span><span class="o">,</span> <span class="o">~&gt;}</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>

<span class="c1">// the program will crash if a key is not found,
// or if a type is incorrectly specified.
</span><span class="k">def</span> <span class="n">impureCompiler</span><span class="k">:</span> <span class="kt">KVStoreA</span> <span class="kt">~&gt;</span> <span class="kt">Id</span>  <span class="o">=</span>
  <span class="k">new</span> <span class="o">(</span><span class="nc">KVStoreA</span> <span class="o">~&gt;</span> <span class="nc">Id</span><span class="o">)</span> <span class="o">{</span>

    <span class="c1">// a very simple (and imprecise) key-value store
</span>    <span class="k">val</span> <span class="n">kvs</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">]</span>

    <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">KVStoreA</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"put($key, $value)"</span><span class="o">)</span>
          <span class="n">kvs</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">=</span> <span class="n">value</span>
          <span class="o">()</span>
        <span class="k">case</span> <span class="nc">Get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"get($key)"</span><span class="o">)</span>
          <span class="n">kvs</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
        <span class="k">case</span> <span class="nc">Delete</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"delete($key)"</span><span class="o">)</span>
          <span class="n">kvs</span><span class="o">.</span><span class="n">remove</span><span class="o">(</span><span class="n">key</span><span class="o">)</span>
          <span class="o">()</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre>
</div>

<p>Please note this <code class="highlighter-rouge">impureCompiler</code> is impure – it mutates <code class="highlighter-rouge">kvs</code> and
also produces logging output using <code class="highlighter-rouge">println</code>.  The whole purpose of
functional programming isn’t to prevent side-effects, it is just to
push side-effects to the boundaries of your system in a well-known and
controlled way.</p>

<p><code class="highlighter-rouge">Id[_]</code> represents the simplest type container: the type itself. Thus,
<code class="highlighter-rouge">Id[Int]</code> is just <code class="highlighter-rouge">Int</code>. This means that our program will execute
immediately, and block until the final value can be returned.</p>

<p>However, we could easily use other type containers for different
behavior, such as:</p>

<ul>
  <li><code class="highlighter-rouge">Future[_]</code> for asynchronous computation</li>
  <li><code class="highlighter-rouge">List[_]</code> for gathering multiple results</li>
  <li><code class="highlighter-rouge">Option[_]</code> to support optional results</li>
  <li><code class="highlighter-rouge">Either[E, ?]</code> to support failure</li>
  <li>a pseudo-random monad to support non-determinism</li>
  <li>and so on…</li>
</ul>

<h4 id="run-your-program">5. Run your program</h4>

<p>The final step is naturally running your program after compiling it.</p>

<p><code class="highlighter-rouge">Free[_]</code> is just a recursive structure that can be seen as sequence
of operations producing other operations. In this way it is similar to
<code class="highlighter-rouge">List[_]</code>. We often use folds (e.g. <code class="highlighter-rouge">foldRight</code>) to obtain a single
value from a list; this recurses over the structure, combining its
contents.</p>

<p>The idea behind running a <code class="highlighter-rouge">Free[_]</code> is exactly the same. We fold the
recursive structure by:</p>

<ul>
  <li>consuming each operation.</li>
  <li>compiling the operation into our effective language using
  <code class="highlighter-rouge">impureCompiler</code> (applying its effects if any).</li>
  <li>computing next operation.</li>
  <li>continue recursively until reaching a <code class="highlighter-rouge">Pure</code> state, and returning it.</li>
</ul>

<p>This operation is called <code class="highlighter-rouge">Free.foldMap</code>:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">final</span> <span class="k">def</span> <span class="n">foldMap</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">f</span><span class="k">:</span> <span class="kt">FunctionK</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">M</span><span class="o">])(</span><span class="n">M</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">M</span><span class="o">])</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">M</code> must be a <code class="highlighter-rouge">Monad</code> to be flattenable (the famous monoid aspect
under <code class="highlighter-rouge">Monad</code>). As <code class="highlighter-rouge">Id</code> is a <code class="highlighter-rouge">Monad</code>, we can use <code class="highlighter-rouge">foldMap</code>.</p>

<p>To run your <code class="highlighter-rouge">Free</code> with previous <code class="highlighter-rouge">impureCompiler</code>:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">program</span><span class="o">.</span><span class="n">foldMap</span><span class="o">(</span><span class="n">impureCompiler</span><span class="o">)</span>
<span class="c1">// put(wild-cats, 2)
// get(wild-cats)
// put(wild-cats, 14)
// put(tame-cats, 5)
// get(wild-cats)
// delete(tame-cats)
// result: Option[Int] = Some(14)
</span></code></pre>
</div>

<p>An important aspect of <code class="highlighter-rouge">foldMap</code> is its <strong>stack-safety</strong>. It evaluates
each step of computation on the stack then unstack and restart. This
process is known as trampolining.</p>

<p>As long as your natural transformation is stack-safe, <code class="highlighter-rouge">foldMap</code> will
never overflow your stack.  Trampolining is heap-intensive but
stack-safety provides the reliability required to use <code class="highlighter-rouge">Free[_]</code> for
data-intensive tasks, as well as infinite processes such as streams.</p>

<h4 id="use-a-pure-compiler-optional">6. Use a pure compiler (optional)</h4>

<p>The previous examples used an effectful natural transformation. This
works, but you might prefer folding your <code class="highlighter-rouge">Free</code> in a “purer” way. The
<a href="state.html">State</a> data structure can be used to keep track of the program
state in an immutable map, avoiding mutation altogether.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.State</span>

<span class="k">type</span> <span class="kt">KVStoreState</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">State</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span>
<span class="k">val</span> <span class="n">pureCompiler</span><span class="k">:</span> <span class="kt">KVStoreA</span> <span class="kt">~&gt;</span> <span class="kt">KVStoreState</span> <span class="o">=</span> <span class="k">new</span> <span class="o">(</span><span class="nc">KVStoreA</span> <span class="o">~&gt;</span> <span class="nc">KVStoreState</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">KVStoreA</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">KVStoreState</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">State</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">updated</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">))</span>
      <span class="k">case</span> <span class="nc">Get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nc">State</span><span class="o">.</span><span class="n">inspect</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">A</span><span class="o">]))</span>
      <span class="k">case</span> <span class="nc">Delete</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">State</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">-</span> <span class="n">key</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>(You can see that we are again running into some places where Scala’s
support for pattern matching is limited by the JVM’s type erasure, but
it’s not too hard to get around.)</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="o">(</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">],</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="n">program</span><span class="o">.</span><span class="n">foldMap</span><span class="o">(</span><span class="n">pureCompiler</span><span class="o">).</span><span class="n">run</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">).</span><span class="n">value</span>
<span class="c1">// result: (Map[String,Any], Option[Int]) = (Map(wild-cats -&gt; 14),Some(14))
</span></code></pre>
</div>

<h2 id="composing-free-monads-adts">Composing Free monads ADTs.</h2>

<p>Real world applications often time combine different algebras.
The injection type class described by Swierstra in <a href="http://www.staff.science.uu.nl/~swier004/publications/2008-jfp.pdf">Data types à la carte</a>
lets us compose different algebras in the context of <code class="highlighter-rouge">Free</code>.</p>

<p>Let’s see a trivial example of unrelated ADT’s getting composed as a <code class="highlighter-rouge">EitherK</code> that can form a more complex program.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.EitherK</span>
<span class="k">import</span> <span class="nn">cats.free.Free</span>
<span class="k">import</span> <span class="nn">cats.</span><span class="o">{</span><span class="nc">Id</span><span class="o">,</span> <span class="nc">InjectK</span><span class="o">,</span> <span class="o">~&gt;}</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable.ListBuffer</span>
</code></pre>
</div>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="cm">/* Handles user interaction */</span>
<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Interact</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">Ask</span><span class="o">(</span><span class="n">prompt</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Interact</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Tell</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Interact</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>

<span class="cm">/* Represents persistence operations */</span>
<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">DataOp</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">AddCat</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">DataOp</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">GetAllCats</span><span class="o">()</span> <span class="k">extends</span> <span class="nc">DataOp</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span>
</code></pre>
</div>

<p>Once the ADTs are defined we can formally state that a <code class="highlighter-rouge">Free</code> program is the EitherK of it’s Algebras.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">type</span> <span class="kt">CatsApp</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">EitherK</span><span class="o">[</span><span class="kt">DataOp</span>, <span class="kt">Interact</span>, <span class="kt">A</span><span class="o">]</span>
</code></pre>
</div>

<p>In order to take advantage of monadic composition we use smart constructors to lift our Algebra to the <code class="highlighter-rouge">Free</code> context.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Interacts</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">I</span><span class="k">:</span> <span class="kt">InjectK</span><span class="o">[</span><span class="kt">Interact</span>, <span class="kt">F</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">tell</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Free</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Free</span><span class="o">.</span><span class="n">inject</span><span class="o">[</span><span class="kt">Interact</span>, <span class="kt">F</span><span class="o">](</span><span class="nc">Tell</span><span class="o">(</span><span class="n">msg</span><span class="o">))</span>
  <span class="k">def</span> <span class="n">ask</span><span class="o">(</span><span class="n">prompt</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Free</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Free</span><span class="o">.</span><span class="n">inject</span><span class="o">[</span><span class="kt">Interact</span>, <span class="kt">F</span><span class="o">](</span><span class="nc">Ask</span><span class="o">(</span><span class="n">prompt</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Interacts</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">interacts</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">I</span><span class="k">:</span> <span class="kt">InjectK</span><span class="o">[</span><span class="kt">Interact</span>, <span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Interacts</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Interacts</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">DataSource</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">I</span><span class="k">:</span> <span class="kt">InjectK</span><span class="o">[</span><span class="kt">DataOp</span>, <span class="kt">F</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">addCat</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Free</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Free</span><span class="o">.</span><span class="n">inject</span><span class="o">[</span><span class="kt">DataOp</span>, <span class="kt">F</span><span class="o">](</span><span class="nc">AddCat</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
  <span class="k">def</span> <span class="n">getAllCats</span><span class="k">:</span> <span class="kt">Free</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Free</span><span class="o">.</span><span class="n">inject</span><span class="o">[</span><span class="kt">DataOp</span>, <span class="kt">F</span><span class="o">](</span><span class="nc">GetAllCats</span><span class="o">())</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">DataSource</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">dataSource</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">I</span><span class="k">:</span> <span class="kt">InjectK</span><span class="o">[</span><span class="kt">DataOp</span>, <span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">DataSource</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">DataSource</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">}</span>
</code></pre>
</div>

<p>ADTs are now easily composed and trivially intertwined inside monadic contexts.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">program</span><span class="o">(</span><span class="k">implicit</span> <span class="n">I</span> <span class="k">:</span> <span class="kt">Interacts</span><span class="o">[</span><span class="kt">CatsApp</span><span class="o">],</span> <span class="n">D</span> <span class="k">:</span> <span class="kt">DataSource</span><span class="o">[</span><span class="kt">CatsApp</span><span class="o">])</span><span class="k">:</span> <span class="kt">Free</span><span class="o">[</span><span class="kt">CatsApp</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="k">import</span> <span class="nn">I._</span><span class="o">,</span> <span class="n">D</span><span class="o">.</span><span class="k">_</span>

  <span class="k">for</span> <span class="o">{</span>
    <span class="n">cat</span> <span class="k">&lt;-</span> <span class="n">ask</span><span class="o">(</span><span class="s">"What's the kitty's name?"</span><span class="o">)</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">addCat</span><span class="o">(</span><span class="n">cat</span><span class="o">)</span>
    <span class="n">cats</span> <span class="k">&lt;-</span> <span class="n">getAllCats</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">tell</span><span class="o">(</span><span class="n">cats</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Finally we write one interpreter per ADT and combine them with a <code class="highlighter-rouge">FunctionK</code> to <code class="highlighter-rouge">EitherK</code> so they can be
compiled and applied to our <code class="highlighter-rouge">Free</code> program.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">object</span> <span class="nc">ConsoleCatsInterpreter</span> <span class="k">extends</span> <span class="o">(</span><span class="nc">Interact</span> <span class="o">~&gt;</span> <span class="nc">Id</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">Interact</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="n">i</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Ask</span><span class="o">(</span><span class="n">prompt</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">prompt</span><span class="o">)</span>
      <span class="n">readLine</span><span class="o">()</span>
    <span class="k">case</span> <span class="nc">Tell</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">InMemoryDatasourceInterpreter</span> <span class="k">extends</span> <span class="o">(</span><span class="nc">DataOp</span> <span class="o">~&gt;</span> <span class="nc">Id</span><span class="o">)</span> <span class="o">{</span>

  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">val</span> <span class="n">memDataSet</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">DataOp</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">AddCat</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">memDataSet</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">a</span><span class="o">);</span> <span class="o">()</span>
    <span class="k">case</span> <span class="nc">GetAllCats</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">memDataSet</span><span class="o">.</span><span class="n">toList</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">interpreter</span><span class="k">:</span> <span class="kt">CatsApp</span> <span class="kt">~&gt;</span> <span class="kt">Id</span> <span class="o">=</span> <span class="nc">InMemoryDatasourceInterpreter</span> <span class="n">or</span> <span class="nc">ConsoleCatsInterpreter</span>
</code></pre>
</div>

<p>Now if we run our program and type in “snuggles” when prompted, we see something like this:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">DataSource._</span><span class="o">,</span> <span class="nc">Interacts</span><span class="o">.</span><span class="k">_</span>
</code></pre>
</div>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">evaled</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">program</span><span class="o">.</span><span class="n">foldMap</span><span class="o">(</span><span class="n">interpreter</span><span class="o">)</span>
<span class="c1">// What's the kitty's name?
// List(snuggles)
// evaled: Unit = ()
</span></code></pre>
</div>

<h2 id="a-namewhat-is-free-in-theoryafor-the-curious-ones-what-is-free-in-theory"><a name="what-is-free-in-theory"></a>For the curious ones: what is Free in theory?</h2>

<p>Mathematically-speaking, a <em>free monad</em> (at least in the programming
language context) is a construction that is left adjoint to a
forgetful functor whose domain is the category of Monads and whose
co-domain is the category of Endofunctors. Huh?</p>

<p>Concretely, <strong>it is just a clever construction that allows us to build a
<em>very simple</em> Monad from any <em>functor</em></strong>.</p>

<p>The above forgetful functor takes a <code class="highlighter-rouge">Monad</code> and:</p>

<ul>
  <li>forgets its <em>monadic</em> part (e.g. the <code class="highlighter-rouge">flatMap</code> function)</li>
  <li>forgets its <em>pointed</em> part (e.g. the <code class="highlighter-rouge">pure</code> function)</li>
  <li>finally keeps the <em>functor</em> part (e.g. the <code class="highlighter-rouge">map</code> function)</li>
</ul>

<p>By reversing all arrows to build the left-adjoint, we deduce that the
free monad is basically a construction that:</p>

<ul>
  <li>takes a <em>functor</em></li>
  <li>adds the <em>pointed</em> part (e.g. <code class="highlighter-rouge">pure</code>)</li>
  <li>adds the <em>monadic</em> behavior (e.g. <code class="highlighter-rouge">flatMap</code>)</li>
</ul>

<p>In terms of implementation, to build a <em>monad</em> from a <em>functor</em> we use
the following classic inductive definition:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">Pure</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">]</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Suspend</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Free</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">]])</span> <span class="k">extends</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">]</span>
</code></pre>
</div>

<p>(<em>This generalizes the concept of fixed point functor</em>.)</p>

<p>In this representation:</p>

<ul>
  <li><code class="highlighter-rouge">Pure</code> builds a <code class="highlighter-rouge">Free</code> instance from an <code class="highlighter-rouge">A</code> value (it <em>reifies</em> the
<code class="highlighter-rouge">pure</code> function)</li>
  <li><code class="highlighter-rouge">Suspend</code> builds a new <code class="highlighter-rouge">Free</code> by applying <code class="highlighter-rouge">F</code> to a previous <code class="highlighter-rouge">Free</code>
(it <em>reifies</em> the <code class="highlighter-rouge">flatMap</code> function)</li>
</ul>

<p>So a typical <code class="highlighter-rouge">Free</code> structure might look like:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="nc">Suspend</span><span class="o">(</span><span class="n">F</span><span class="o">(</span><span class="nc">Suspend</span><span class="o">(</span><span class="n">F</span><span class="o">(</span><span class="nc">Suspend</span><span class="o">(</span><span class="n">F</span><span class="o">(....(</span><span class="nc">Pure</span><span class="o">(</span><span class="n">a</span><span class="o">))))))))</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">Free</code> is a recursive structure. It uses <code class="highlighter-rouge">A</code> in <code class="highlighter-rouge">F[A]</code> as the
recursion “carrier” with a terminal element <code class="highlighter-rouge">Pure</code>.</p>

<p>From a computational point of view, <code class="highlighter-rouge">Free</code> recursive structure can be
seen as a sequence of operations.</p>

<ul>
  <li><code class="highlighter-rouge">Pure</code> returns an <code class="highlighter-rouge">A</code> value and ends the entire computation.</li>
  <li><code class="highlighter-rouge">Suspend</code> is a continuation; it suspends the current computation
with the suspension functor <code class="highlighter-rouge">F</code> (which can represent a command for
example) and hands control to the caller. <code class="highlighter-rouge">A</code> represents a value
bound to this computation.</li>
</ul>

<p>Please note this <code class="highlighter-rouge">Free</code> construction has the interesting quality of
<em>encoding</em> the recursion on the heap instead of the stack as classic
function calls would. This provides the stack-safety we heard about
earlier, allowing very large <code class="highlighter-rouge">Free</code> structures to be evaluated safely.</p>

<h3 id="for-the-very-curious-ones">For the very curious ones</h3>

<p>If you look at implementation in cats, you will see another member of
the <code class="highlighter-rouge">Free[_]</code> ADT:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">FlatMapped</span><span class="o">[</span><span class="kt">S</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">Free</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">C</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=&gt;</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">B</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">B</span><span class="o">]</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">FlatMapped</code> represents a call to a subroutine <code class="highlighter-rouge">c</code> and when <code class="highlighter-rouge">c</code> is
finished, it continues the computation by calling the function <code class="highlighter-rouge">f</code>
with the result of <code class="highlighter-rouge">c</code>.</p>

<p>It is actually an optimization of <code class="highlighter-rouge">Free</code> structure allowing to solve a
problem of quadratic complexity implied by very deep recursive <code class="highlighter-rouge">Free</code>
computations.</p>

<p>It is exactly the same problem as repeatedly appending to a <code class="highlighter-rouge">List[_]</code>.
As the sequence of operations becomes longer, the slower a <code class="highlighter-rouge">flatMap</code>
“through” the structure will be. With <code class="highlighter-rouge">FlatMapped</code>, <code class="highlighter-rouge">Free</code> becomes a
right-associated structure not subject to quadratic complexity.</p>

<h2 id="freet">FreeT</h2>

<p>Often times we want to interleave the syntax tree when building a Free monad
with some other effect not declared as part of the ADT.
FreeT solves this problem by allowing us to mix building steps of the AST
with calling action in other base monad.</p>

<p>In the following example a basic console application is shown.
When the user inputs some text we use a separate <code class="highlighter-rouge">State</code> monad to track what the user
typed.</p>

<p>As we can observe in this case <code class="highlighter-rouge">FreeT</code> offers us a the alternative to delegate denotations to <code class="highlighter-rouge">State</code>
monad with stronger equational guarantees than if we were emulating the <code class="highlighter-rouge">State</code> ops in our own ADT.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.free._</span>
<span class="c1">// import cats.free._
</span>
<span class="k">import</span> <span class="nn">cats._</span>
<span class="c1">// import cats._
</span>
<span class="k">import</span> <span class="nn">cats.data._</span>
<span class="c1">// import cats.data._
</span>
<span class="cm">/* A base ADT for the user interaction without state semantics */</span>
<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Teletype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Product</span> <span class="k">with</span> <span class="nc">Serializable</span>
<span class="c1">// defined class Teletype
</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">WriteLine</span><span class="o">(</span><span class="n">line</span> <span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Teletype</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="c1">// defined class WriteLine
</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">ReadLine</span><span class="o">(</span><span class="n">prompt</span> <span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Teletype</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="c1">// defined class ReadLine
</span>
<span class="k">type</span> <span class="kt">TeletypeT</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">FreeT</span><span class="o">[</span><span class="kt">Teletype</span>, <span class="kt">M</span>, <span class="kt">A</span><span class="o">]</span>
<span class="c1">// defined type alias TeletypeT
</span>
<span class="k">type</span> <span class="kt">Log</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="c1">// defined type alias Log
</span>
<span class="k">type</span> <span class="kt">TeletypeState</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">State</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span>
<span class="c1">// defined type alias TeletypeState
</span>
<span class="cm">/** Teletype smart constructors */</span>
<span class="k">object</span> <span class="nc">TeletypeOps</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">writeLine</span><span class="o">(</span><span class="n">line</span> <span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">:</span> <span class="kt">TeletypeT</span><span class="o">[</span><span class="kt">TeletypeState</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
	<span class="nc">FreeT</span><span class="o">.</span><span class="n">liftF</span><span class="o">[</span><span class="kt">Teletype</span>, <span class="kt">TeletypeState</span>, <span class="kt">Unit</span><span class="o">](</span><span class="nc">WriteLine</span><span class="o">(</span><span class="n">line</span><span class="o">))</span>
  <span class="k">def</span> <span class="n">readLine</span><span class="o">(</span><span class="n">prompt</span> <span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">:</span> <span class="kt">TeletypeT</span><span class="o">[</span><span class="kt">TeletypeState</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
	<span class="nc">FreeT</span><span class="o">.</span><span class="n">liftF</span><span class="o">[</span><span class="kt">Teletype</span>, <span class="kt">TeletypeState</span>, <span class="kt">String</span><span class="o">](</span><span class="nc">ReadLine</span><span class="o">(</span><span class="n">prompt</span><span class="o">))</span>
  <span class="k">def</span> <span class="n">log</span><span class="o">(</span><span class="n">s</span> <span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">:</span> <span class="kt">TeletypeT</span><span class="o">[</span><span class="kt">TeletypeState</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
	<span class="nc">FreeT</span><span class="o">.</span><span class="n">liftT</span><span class="o">[</span><span class="kt">Teletype</span>, <span class="kt">TeletypeState</span>, <span class="kt">Unit</span><span class="o">](</span><span class="nc">State</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="n">s</span> <span class="o">::</span> <span class="k">_</span><span class="o">))</span>
<span class="o">}</span>
<span class="c1">// defined object TeletypeOps
</span>
<span class="k">def</span> <span class="n">program</span> <span class="k">:</span> <span class="kt">TeletypeT</span><span class="o">[</span><span class="kt">TeletypeState</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">{</span>
	<span class="n">userSaid</span> <span class="k">&lt;-</span> <span class="nc">TeletypeOps</span><span class="o">.</span><span class="n">readLine</span><span class="o">(</span><span class="s">"what's up?!"</span><span class="o">)</span>
	<span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">TeletypeOps</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="n">s</span><span class="s">"user said : $userSaid"</span><span class="o">)</span>
	<span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">TeletypeOps</span><span class="o">.</span><span class="n">writeLine</span><span class="o">(</span><span class="s">"thanks, see you soon!"</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
<span class="o">}</span>
<span class="c1">// program: TeletypeT[TeletypeState,Unit]
</span>
<span class="k">def</span> <span class="n">interpreter</span> <span class="k">=</span> <span class="k">new</span> <span class="o">(</span><span class="nc">Teletype</span> <span class="o">~&gt;</span> <span class="nc">TeletypeState</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span> <span class="k">:</span> <span class="kt">Teletype</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">:</span> <span class="kt">TeletypeState</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
	<span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
	  <span class="k">case</span> <span class="nc">ReadLine</span><span class="o">(</span><span class="n">prompt</span><span class="o">)</span> <span class="k">=&gt;</span>
		<span class="n">println</span><span class="o">(</span><span class="n">prompt</span><span class="o">)</span>
		<span class="k">val</span> <span class="n">userInput</span> <span class="k">=</span> <span class="s">"hanging in here"</span> <span class="c1">//scala.io.StdIn.readLine()
</span>		<span class="nc">StateT</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">Eval</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">userInput</span><span class="o">)</span>
	  <span class="k">case</span> <span class="nc">WriteLine</span><span class="o">(</span><span class="n">line</span><span class="o">)</span> <span class="k">=&gt;</span>
		<span class="nc">StateT</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">Eval</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">println</span><span class="o">(</span><span class="n">line</span><span class="o">))</span>
	<span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// interpreter: Teletype ~&gt; TeletypeState
</span>
<span class="k">import</span> <span class="nn">TeletypeOps._</span>
<span class="c1">// import TeletypeOps._
</span>
<span class="k">val</span> <span class="n">state</span> <span class="k">=</span> <span class="n">program</span><span class="o">.</span><span class="n">foldMap</span><span class="o">(</span><span class="n">interpreter</span><span class="o">)</span>
<span class="c1">// state: TeletypeState[Unit] = cats.data.IndexedStateT@7bdc3999
</span>
<span class="k">val</span> <span class="n">initialState</span> <span class="k">=</span> <span class="nc">Nil</span>
<span class="c1">// initialState: scala.collection.immutable.Nil.type = List()
</span>
<span class="k">val</span> <span class="o">(</span><span class="n">stored</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=</span> <span class="n">state</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">initialState</span><span class="o">).</span><span class="n">value</span>
<span class="c1">// what's up?!
// thanks, see you soon!
// stored: List[String] = List(user said : hanging in here)
</span></code></pre>
</div>

<h2 id="future-work-todo">Future Work (TODO)</h2>

<p>There are many remarkable uses of <code class="highlighter-rouge">Free[_]</code>. In the future, we will
include some here, such as:</p>

<ul>
  <li>Trampoline</li>
  <li>Option</li>
  <li>Iteratee</li>
  <li>Source</li>
  <li>etc…</li>
</ul>

<p>We will also discuss the <em>Coyoneda Trick</em>.</p>

<h2 id="credits">Credits</h2>

<p>This article was written by
<a href="https://github.com/mandubian">Pascal Voitot</a> and edited by other
members of the Cats community.</p>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/cats/highlight/highlight.pack.js"></script><script>hljs.configure({
languages:['scala','java','bash']
});
hljs.initHighlighting();
             </script><script>((window.gitter = {}).chat = {}).options = {
room: 'typelevel/cats'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/cats/js/main.js"></script><script src="/cats/js/kazari.js"></script><script>
$(document).ready(function() {
	kazari.KazariPlugin().decorateCode('https://scala-evaluator-212.herokuapp.com/eval', 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.S2F6YXJp.Jl2eqMfw8IakJF93PjxTbrf-8YUJgX5OoOfy5JHE8Yw', '', 'monokai')
})
    </script></body></html>